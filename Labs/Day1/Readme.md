# Refactoring "TheatricalPlays"
### Background: 

This project contains a bill generator for a theatrical company.
This company charges their customers based on the size of the audience and the type of play.
Currently they are using a .NET 6 console application to generate a plain text bill.

Beside providing a bill, it also outputs the customers "volume credits", which is used to calculate a discount for repeat customers.
Every 10 credits earns a customer 1 percentage point up to a maximum discount of 30% of the total bill.

The plays this company can perform are stored in a simple JSON file.
The performances that were performed for a customer are stored another JSON file containing the playid and the audience.

## Target Environment
* .NET Core 6.0
* This lab expects the default keybindings. If you're using a different keymap, please look up the keyboard shortcuts used in this lab.

### Build
* Visual Studio 2022 v17.0+ 

# Goal
The company wants to perform more types of plays. <br />
They hope to perform: historical, pastoral, pastoral-comical, historical-pastoral, tragical-comical-historical-pastoral and poem unlimited.
Although the pricing structure and the volume credit calculations are not fully worked out, it appears that this will be under subject of change in the near future.

Furthermore, the company wants to send out HTML formatted statements to some customers.

In order to do so, 
1. you would either have to copy-paste the current `BillGenerator.Statement` implementation into a HTML statement generator with all code duplicated.
2. Or, first refactor the current implementation to a improved design more suitable for the upcoming features/requests.

In this lab we are going to perform the steps needed for the latter (of course :))

# Part 1. First steps
## Extract function
As a first step, let's begin by extracting functionality from the current long `Statement` function.
The `switch` statement related to calculating the charge of a performance is a good start as it is performs 1 thing that we can return in a method.

We are going to begin with performing a **Extract Method** refactoring on this statement.<br />
Select line 22 till 45 in `BillGenerator.cs` and apply the **Extract method** refactoring from Visual Studio (either via Edit > Refactor > Extract Method or using the Ctrl+. "quick actions" > Extract ).
And name the newly extracted function `AmountFor`. (We can always rename it later to a more suitable name).
We finish the first refactoring by running our unittests to verify that we did not break anything and committing the first change

Next, apply the **Rename variable** refactoring from Visual Studio on the `thisAmount` variable in the `AmountFor` method and rename it to `result`
Again compile-test-commit.

Apply the same **Rename variable** refactoring on the `perf` parameter of `AmountFor`. Rename it to `performance`, compile test and commit.

## Removing the `play` variable
The next refactoring we want to apply is regarding the `play` parameter.<br />
This parameter is just a computation based on the performance playID and as we already have a Performance object as parameter, there should not be a need to pass it in as we could also calculate it ourselves.
Meaning that we want to remove the `play` parameter.

However here the design of the `Statement` method holds us back, as the dictionary containing all plays is a local parameter.
Meaning that we need to promote the `plays` parameter into a instance variable (in C# called *Fields*) of the class `BillGenerator`
Let's start with adding `private readonly IReadOnlyDictionary<string, Play> plays;` to the top of the class.

Now we *could* assign the `plays` parameter directly to the instance variable by using `this.plays = plays;` within the Statement method, 
however this would set us on a slippery slope as it would not be easy to separate between the local parameter and the instance variable.
Instead we want to signal to the users of `BillGenerator` that it always requires a `IReadOnlyDictionary<string, Play> plays` using the constructor.

The new constructor can automatically be generated by Visual Studio. 
Place the text cursor/caret somewhere within the `BillGenerator` on line 8 and bring up the "quick actions" menu using Ctrl+.
Select the "Generate constructor..." option. Press "OK" on the dialog and a constructor should be generated.
Now we can use the **_lean on compiler_** action to identify all the places that need to be changed due to the added constructor parameter.
Resolve each compiler error.

Finally we are going to switch into using the instance variable by removing the `plays` parameter using the **Change function declaration** refactoring.
Place the cursor somewhere on the line `public string Statement(Invoice invoice, IReadOnlyDictionary<string, Play> plays)` and bring up the "quick actions" menu.
Select the "Change signature..." option. In the dialog that opens, select the `plays` parameter, press the Remove button and finally press "OK" to apply the changes.
With this refactoring, the instance variable should now be used.
Test the changes to ensure that the external behavior was not modified and commit when all tests are green.

Next, encapsulate the lookup of a play based on it's performance in a separate function.
Select this whole line `var play = plays[perf.PlayId];` (around line 28 within `Statement` function), 
apply the **Extract Method** refactoring and name the newly created method `PlayFor`.
Compile-test-commit.

Apply the **Inline variable** refactoring on the `play` variable.
Place the cursor on the `play`, bring up the "quick actions" context menu and select the option "Inline temporary variable".
As always after a refactor action, compile-test-commit.

With this new `PlayFor` function, we can begin removing the `play` parameter from the `AmountFor` function.
First, use the new function in `amountFor` by replacing the 2 usages of the `play` variable with a call to `PlayFor(performance)`.
And as `AmountFor` now uses non-static methods, remove the static keyword.
Compile-test-commit

Then delete the now unused `play` parameter using the **Change function declaration** refactoring.
And compile-test-commit again.

As a final refactoring during this step, apply the **Inline variable** refactoring on the `thisAmount` variable

Your `BillGenerator` class should look something like the one in folder `src\01 First Steps`

# Part 2. Extracting Volume Credits
Next we want to extract the `volumeCredits` calculation from the foreach loop.
Unfortunately due to `volumeCredits` accumulator, we cannot rely on the automated **"Extract Method"** functionality.
Instead we are going to perform the **Extract Method** refactoring manually. 
First create a new method named `VolumeCreditsFor`:
```c#
private int VolumeCreditsFor(Performance perf)
{

}
```
Then copy the volume credit calculation block into `VolumeCreditsFor`:
```c#
private int VolumeCreditsFor(Performance perf)
{
    // add volume credits
    volumeCredits += Math.Max(perf.Audience - 30, 0);
    // add extra credit for every ten comedy attendees
    if (PlayType.Comedy == PlayFor(perf).Type) volumeCredits += (int)Math.Floor((decimal)perf.Audience / 5);
}
```
Add the missing variable to resolve the compiler errors and return it:
```c#
private int VolumeCreditsFor(Performance perf)
{
    var volumeCredits = 0;
    // add volume credits
    volumeCredits += Math.Max(perf.Audience - 30, 0);
    // add extra credit for every ten comedy attendees
    if (PlayType.Comedy == PlayFor(perf).Type) volumeCredits += (int)Math.Floor((decimal)perf.Audience / 5);

    return volumeCredits;
}
```

Replace to copied code with a call to `VolumeCreditsFor`:
```c#
            foreach (var perf in invoice.Performances)
            {
                volumeCredits += VolumeCreditsFor(perf);
```

Compile-test-commit to finish of this manual **Extract Method** refactoring.
Lastly, remove the unnecessary (and even misleading) comments and **Rename variable** in the new function, 
renaming `volumeCredits` to `result` and `perf` to `performance` with a compile-test-commit action for each rename.

Next we are going to remove the `volumeCredits` from `Statement`.
As it is nested in the foreach loop, we are going to apply the **Split Loop** refactoring (see slides for the steps involved)
```c#
            foreach (var perf in invoice.Performances)
            {
                // print line for this order
                result.Append($"  {this.PlayFor(perf).Name}: {(AmountFor(perf) / 100).ToString("C", format)}");
                result.AppendLine($" ({perf.Audience} seats)");
                totalAmount += AmountFor(perf);
            }

            foreach (var perf in invoice.Performances)
            {
                volumeCredits += VolumeCreditsFor(perf);
            }
```
Compile-test-commit

Then using **Slide Statements** (see hidden slide 20), move the declaration of the `volumeCredits` variable before the loop:
```c#
            var volumeCredits = 0;
            foreach (var perf in invoice.Performances)
            {
                volumeCredits += VolumeCreditsFor(perf);
            }
```
Compile-test-commit

Gathering this all together means that we can now use the automated **Extract Method** refactoring to create a new method `GetTotalVolumeCredits`.
After compiling, testing and committing; apply **Inline variable** on `volumeCredits`

Your `BillGenerator` class should look something like the one in folder `src\02 Extract Volume Credits`

# Part 3. More extractions
In order to remove the variable `totalAmount` we can use the same steps as before.
First **Split loop** on the first foreach loop.
After this refactoring it should look like below:
```c#
            foreach (var perf in invoice.Performances)
            {
                // print line for this order
                result.Append($"  {this.PlayFor(perf).Name}: {(AmountFor(perf) / 100).ToString("C", format)}");
                result.AppendLine($" ({perf.Audience} seats)");
            }

            foreach (var perf in invoice.Performances)
            {
                totalAmount += AmountFor(perf);
            }
```
Compile-test-commit.

Then using **Slide Statements** on `decimal totalAmount = 0;` closer to the loop. 
Compile-test-commit
Select all the lines related to calculating `totalAmount`, including the discount, and apply **Extract Method** refactoring to create a new method `GetTotalAmount`.
Compile-test-commit
**Inline variable** `totalAmount` (compile-test-commit) in `Statement`  function.
In `GetTotalAmount` method **Rename variable** `totalAmount` to `result`

Lastly let's extract the currency formatting.<br />
As both the `AmountFor(perf)` and `GetTotalAmount(invoice)` use the same kind of code, let's **Extract method** on this functionality.
Here we need to again perform a manual refactoring as the automated tooling does not suffice.
Given that this method will format an amount into USD, we could name it as `FormatAsUSD` but `Usd` is just as suggestive so we go with latter.
```c#
        private string Usd(decimal amount)
        {

        }
```

Next, move the code related to the amount formatting in the new function:
```c#
        private string Usd(decimal amount)
        {
            IFormatProvider format = new CultureInfo("en-US");
            return (amount / 100).ToString("C", format);
        }
```
Note that we included the duplicate division by 100 into the `Usd` method.
Now, replace the number formatting with the `Usd` method. 
Testing after each replacement.
Remove the used `format` variable from `Statement`

As a final refactoring in this part, **Inline variable** on `format` in `Usd`

Your `BillGenerator` class should look something like the one in folder `src\03 More extractions`

# Part 4. Split phase and adding render HTML
So far, we worked on bringing structure onto the original function so that we can easily understand the various parts.
In order to add the HTML support, we could stop now, just copy the seven or so lines remaining in `Statement`, create an HTML variant and call it a day.<br/>
This does mean however that the logic for what is required to generate a bill is still duplicated.

Therefor we are now going to apply the **Split Phase** refactoring to untangle the logic for calculating the statement data from the logic for rendering text (or later HTML).<br />
As a reminder, with the **Split Phase** refactoring, we begin by extracting the second phase. <br/>
Then create an intermediate data structure, for encapsulation the data calculated in the first phase, followed by gradually copying over all properties onto this structure.<br/>
And lastly, extracting the first phase.

Given that the second phase of the `Statement` function is that of rendering the plaintext bill, we begin by applying the **Extract method** on all the lines in `Statement`.
And we're going to give this method a name descriptive of the second phase, so let's name it: `RenderPlainText`.
Now `Statement` function should look like this:
```c#
        public string Statement(Invoice invoice)
        {
            return RenderPlainText(invoice);
        }
```

Compile-test-commit.

## Creating intermediate data structure `StatementData`
Then create a intermediate data structure. Right-click on the `TheatricalPlays` project within the Solution Explorer and add a new class named `StatementData`.<br />
Next, using the **Change function declaration** (use the change signature functionality in Visual Studio) add a new parameter to the `RenderPlainText` method of type `StatementData` with name `data`.<br />
Create a new variable `statementData` in `Statement` and pass it into the `RenderPlainText` method.<br/>
Now the solution should be in a compilable state.<br/>
So, we start the process of moving data required for the second phase into the intermediate data structure.<br/>

We begin by moving the Customer data into the `StatementData` class. First add `public string Customer { get; init; }` to the `StatementData` class.
> **Note** that we enforce encapsulation by only allowing the name to be set with the constructor by specifying the new **_.Net 5 `init` accessibility modifier_**.
> This defaults into a `private set` without a need for a parameterized constructor and thus ensuring immutability

Change the usage from `invoice.Customer` within `RenderPlainText` into `data.Customer` and add `invoice.Customer` as parameter of the `new StatementData` call.
Compile-test-commit.

The `Statement` method should now look something like this:
```c#
        public string Statement(Invoice invoice)
        {
            var statementData = new StatementData{ Customer = invoice.Customer };
            
            return RenderPlainText(invoice, statementData);
        }
```
And the first few lines of `RenderPlainText` should now look like this:
```c#
        private string RenderPlainText(Invoice invoice, StatementData data)
        {
            var result = new StringBuilder().AppendLine($"Statement for {data.Customer}");

            foreach (var perf in invoice.Performances)
```

We repeat the same process for the `Performances` property. <br/>
Since we want to be sure that this list does not change while we query it, we are going to make the new property of type `ImmutableList`.
> `ReadOnlyList` still allows for changes on the underlying collection to be reflected and is thus still mutable.<br/>
`public ImmutableList<Performance> Performances { get; init; }`. 
Ensure that the updated constructor is called with the correct parameters within `Statement` and that the foreach loop in `RenderPlainText` now uses `data.Performances`.
Compile-test-commit.

Given that both `GetTotalVolumeCredits` and `GetTotalAmount` also use the `invoice.Performances` collection, we want to change both of them into using the `StatementData` intermediate structure.
We start by adding a `StatementData` parameter named `data` to `GetTotalAmount` using the **Change function declaration** refactoring.
If we choose the option `Infer from context` in the "Values to inject in call sites", Visual Studio will fill in the correct parameter within `RenderPlainText`.
Change the `invoice.Performance` invocation into `data.Performances`.
Compile-test-commit.

Then repeat the same steps for `GetTotalVolumeCredits`. Add a StatementData parameter named `data` to `GetTotalVolumeCredits` using the **Change function declaration** refactoring.
Again choose the option `Infer from context`.
Changing into the usage of `data.Performances`.
Compile-test-commit.

With that refactoring, the `invoice` parameter on `GetTotalVolumeCredits` in no longer required. 
Remove this parameter using the **Change function declaration** refactoring.
Compile-test-commit.

And as a result to the clean up within `GetTotalVolumeCredits`, the `invoice` parameter on `GetTotalAmount` is now no longer used.
Remove this parameter using the **Change function declaration** refactoring.
Compile-test-commit.

Finally we can also remove the `invoice` parameter from `RenderPlainText`. Again remove using **Change function declaration** refactoring and finish with compile-test-commit.

## Creating intermediate data structure `EnrichedPerformance`
The next thing we want to move into the intermediate data structure is the retrieval of the play for each performance.
This points us towards yet another intermediate data structure, namely one that encapsulates an enriched performance object.

Add a new class named `EnrichedPerformance` that inherits from `Performance`. Given that we are using the new **_.Net 5 record functionality_**, we need to change `class` into **`record`**.
and create a internal constructor for `EnrichedPerformance` that takes a `Performance` as parameter.
Hint: use the quick actions context menu on EnrichedPerformance to create this constructor and manually change the accessibility from `protected` to `internal`
```c#
namespace TheatricalPlays
{
    record EnrichedPerformance : Performance
    {
        internal EnrichedPerformance(Performance original) : base(original)
        {
        }
    }
}
```

Then change the type used in `StatementData.Performances` to `ImmutableList<EnrichedPerformance>` (updating both the property and the constructor).

We now need to convert the list of `Performance`s into `EnrichedPerformance`. Here we are going to use the `ConvertAll` method from the `ImmutableList` class to ensure that a new immutable list is returned.
This does however require a method that takes in a `Performance` and returns a `EnrichedPerformance` object.
So, add within `BillGenerator` a new private method named `EnrichPerformance` with the appropriate input and output types.

Now your `Statement` method should look like this:
```c#
        public string Statement(Invoice invoice)
        {
            var statementData = new StatementData{ Customer = invoice.Customer, Performances = invoice.Performances.ConvertAll(EnrichPerformance) };
            
            return RenderPlainText(invoice, statementData);
        }
```

Having prepared the groundwork for the second intermediate data structure, move the `Play` property into `EnrichedPerformance` 
and ensure immutability by only specifying a `get`. (This forces a `private set` and the need to set this property via a parameterized constructor).
Add the `Play` parameter to the constructor by placing the caret on 'Play' property, bring up the quick actions context menu and select the "Add parameters to constructor" option.

Resolve the compiler error by adding a call to the `PlayFor` method as argument for the second parameter in the `new` call in `EnrichPerformance`:
```c#
        private EnrichedPerformance EnrichPerformance(Performance performance)
        {
            return new EnrichedPerformance(performance, PlayFor(performance));
        }
```
Replacing the call to `PlayFor(perf)` within `RenderPlainText` with `perf.Play`.
Compile-test-commit

The next thing to move is the `Amount` property. 
We start by adding `Amount` as a get only property to `EnrichedPerformance`. 
Add the new property to `EnrichedPerformance` constructor using Visual Studio quick actions context menu.
Initialize the new argument using a call to `AmountFor(performance)` within `EnrichPerformance`.
Then, in **_all_** methods that use the intermediate data structure `StatementData`, we replace the usage of `AmountFor(perf)` with `perf.Amount`.
Compile-test-commit. (For those wanting to also move the `AmountFor` method, we are going to apply that refactoring in a later stage).

The last property to be moved into the `EnrichedPerformance` data structure is `VolumeCredits`
Repeat the steps above only now for `VolumeCreditsFor` and compile-test-commit.

## Back to intermediate data structure `StatementData`
We move on the replacing the calculation of the two totals.

First let's create a new property `public decimal TotalAmount { get; set; }` within `StatementData`.
As this property is settable from the outside, assign the TotalAmount property with `statementData.TotalAmount = GetTotalAmount(statementData);`.<br />
Replace `GetTotalAmount(data)` in `RenderPlainText` with `data.TotalAmount`.<br/>
Compile-test-commit.

Repeat this process for the property `TotalVolumeCredits`. <br/>When replacing the usage of `GetTotalVolumeCredits(data)` with `data.TotalVolumeCredits`, also update the `GetTotalAmount` method.
Verify that all unittests are green, if not, then we broke the TotalAmount calculation as the volume credits calculation was not yet performed.<br/>
This shows us why it remains important to test after each step.<br/>
Resolve the introduced bug by, for now, switching the order of the `TotalAmount` and `TotalVolumeCredits`.<br/>

All tests should now be green again, and `Statement` should look like this:
```c#
        public string Statement(Invoice invoice)
        {
            var statementData = new StatementData{ Customer = invoice.Customer, Performances = invoice.Performances.ConvertAll(EnrichPerformance) };
            statementData.TotalVolumeCredits = GetTotalVolumeCredits(statementData);
            statementData.TotalAmount = GetTotalAmount(statementData);
            
            return RenderPlainText(statementData);
        }
```

As the current state is very fragile, we are going to move the total calculation into the `StatementData` class.
Copy the `GetTotalAmount` function to `StatementData`. Adjust it to the new context by removing the `data` parameter and using `this` instead of `data`.
Change the `TotalAmount` property into a pass through call to `GetTotalAmount`: `public decimal TotalAmount => GetTotalAmount();`
With that change, we can remove the assignment of `TotalAmount` in `Statement`.<br/>
Compile-test-commit.<br/>
Remove the dead code of `GetTotalAmount` in `BillGenerator`. Always a satisfying feeling!

Repeat the above steps for `GetTotalVolumeCredits`.<br/>
Compile-test-commit

Before we wrap it up, apply the **Replace loop with pipeline** refactoring on each of the total calculation functions.<br/>
Compile-test-commit.

```c#
        private decimal GetTotalAmount()
        {
            decimal totalAmount = this.Performances.Sum(perf => perf.Amount);

            var discountPercentage = Math.Min(30, (this.TotalVolumeCredits / 10));
            totalAmount -= totalAmount * (discountPercentage / 100m);
            return totalAmount;
        }

        private int GetTotalVolumeCredits()
        {
            return this.Performances.Sum(perf => perf.VolumeCredits);
        }
```

## Adding HTML support
Remember that we started all these refactorings as part of the **Split phase** refactoring. 
Now that all data calculations have be encapsulated in `StatementData`, we can apply the last step of this refactoring.
This is the extraction of the first step.
Apply the **Extract Method** refactoring on `var statementData = new StatementData{ Customer = invoice.Customer, Performances = invoice.Performances.ConvertAll(EnrichPerformance) };`
and we are going to call the new method `CreateStatementData`.<br/>
Compile-test-commit.

Apply the **Inline variable** on the `statementData` variable.
```c#
        public string Statement(Invoice invoice)
        {
            return RenderPlainText(CreateStatementData(invoice));
        }
```

And with that we are ready to add the HTML version:
```c#

        public string HtmlStatement(Invoice invoice)
        {
            return RenderHtml(CreateStatementData(invoice));
        }

        private string RenderHtml(StatementData data)
        {
            var result = new StringBuilder().AppendLine($"<h1>Statement for {data.Customer}</h1>");
            result.AppendLine("<table>");
            result.Append("<tr><th>play</th><th>seats</th><th>cost</th></tr>");
            foreach (var perf in data.Performances)
            {
                result.Append($"  <tr><td>{perf.Play.Name}</td><td>{perf.Audience}</td>");
                result.AppendLine($"<td>{Usd(perf.Amount)}</td></tr>");
            }
            result.AppendLine("</table>");
            result.AppendLine($"<p>Amount owed is <em>{Usd(data.TotalAmount)}</em></p>");
            result.AppendLine($"<p>You earned <em>{data.TotalVolumeCredits}</em> credits</p>");
            return result.ToString();
        }
```

Easy.

Your `TheatricalPlays` project should look something like the one in folder `src\04 Split Phase`

# Part 5. Calculations by type
Now that we've added the first request, we'll turn our attention to the second feature request: Supporting more categories of plays, each with its own cost and credits calculation.
As it currently stands, we would have to add more switch statements and conditionals onto `AmountFor` and `VolumeCreditsFor` in order to facilitate such a request, 
which is not the direction we want to go for.

Instead, we are going to apply the refactoring **Replace Conditional with Polymorphism**.

But before we can start applying this refactor action, we first need some kind of inheritance structure.
The `EnrichPerformance` method is here our entry-point as it populates the intermediate data structure using the conditional functions for amount and credits.
We want to host those calculating functions in a class that will become the basis of our inheritance structure.

Due to the expected duties of this class, let's call it `PerformanceCalculator`.
Add a new class `PerformanceCalculator` to the project. In this class add an **`init`** property `Performance` of type `Performance`
Like so:
```c#
namespace TheatricalPlays
{
    class PerformanceCalculator
    {
        public Performance Performance { get; init; }
    }
}
```

And initialize a new `calculator` variable of type `PerformanceCalculator` within the `EnrichPerformance` function,
whereby we are also going to adjust the initialization of `EnrichedPerformance` to use the `calculator.Performance` property.
```c#
        private EnrichedPerformance EnrichPerformance(Performance performance)
        {
            var calculator = new PerformanceCalculator { Performance = performance };

            return new EnrichedPerformance(calculator.Performance, PlayFor(performance), AmountFor(performance), VolumeCreditsFor(performance));
        }
```
Compile-test-commit

Then next property to move into `PerformanceCalculator` is a `Play`, as all conditional logic resolves around what type of `Play` was involved.
Here again, we are going to add a **`init`** property named `Play` to `PerformanceCalculator` and within `EnrichPerformance` this property will be populated using the `PlayFor(..)` call.
As such:
```c#
        private EnrichedPerformance EnrichPerformance(Performance performance)
        {
            var calculator = new PerformanceCalculator { Performance = performance, Play = PlayFor(performance) };

            return new EnrichedPerformance(calculator.Performance, calculator.Play, AmountFor(performance), VolumeCreditsFor(performance));
        }
```
Compile-test-commit

## Moving functions into calculator
With all the required properties now available in the calculator class, we have made it possible to encapsulate the logic for the amount calculation within the class.
Using the **Move Function** refactoring, we first copy the whole `AmountFor` method in `PerformanceCalculator`.
Then adjust to function to its new context, first changing the `performance` parameter with the **Rename Variable** refactoring into `Performance` 
followed by a removal of the `Performance` parameter. And we manually replace 'PlayFor' with a call to `this.Play`.

Next, change the accessibility to `public virtual` (The `virtual` keyword is added as we know we will want to override this function later).
Finally change the function name to a more descriptive `GetAmount`.
After verifying that the solution compiles, we move on to the step of the **Move function** refactoring: calling the new function in the source function.
Update the `AmountFor` method so that it uses the moved function, as per below:
```c#
        private int AmountFor(Performance performance)
        {
            return new PerformanceCalculator() { Performance = performance, Play = PlayFor(performance) }.GetAmount();
        }
```
Test that the refactoring was successful. (Compile-test-commit) <br/>
As the `AmountFor` method is only used once, apply the **Inline function** refactoring on this method.<br/>
Compile-test-commit.

Repeat the same process for volume credits, naming the copied function `GetVolumeCredits`.<br/>
Compile-test-commit.

## Making polymorphic
With all logic in one class, we can move on to create the inheritance structure.
As we can tell from the code in `PerformanceCalculator`, we need two override classes for the various types of play supported.

Add new classes `ComedyCalculator` and `TragedyCalculator`, both of which inherit from `PerformanceCalculator`.

With this we've setup the required inheritance structure and we can move on to the first step of the **Replace Conditional with Polymorphism**:
1. Create a factory function. 
    > Here we can use Factory Method Design Pattern.

    Begin by extracting the current creation of a `PerformanceCalculator` into a new method using **Extract Method**.
    Name this function `CreatePerformanceCalculator`.

    Then extend this function with the creation of the sub-types, based on the play type.
```c#
        private PerformanceCalculator CreatePerformanceCalculator(Performance performance, Play play)
        {
            switch (play.Type)
            {
                case PlayType.Comedy: return new ComedyCalculator { Performance = performance, Play = play };
                case PlayType.Tragedy: return new TragedyCalculator { Performance = performance, Play = play };
                default: throw new Exception($"unknown type: {play.Type}");
            }
        }
```

2. Move conditional code to superclass. As we already performed this step with setting up `PerformanceCalculator`, we skip this step.

3. Take a subclass, create override method for the conditional logic and move the conditional logic into the subclass. <br/>Adjust to fit the new context.<br/>
    We will begin with the `TragedyCalculator`. <br/>
    Create the override method by using the Visual Studio feature "generate overrides".

    Set the caret on "TragedyCalculator" in the cs file. <br />
    Bring up the quick actions menu and select the option "Generate overrides...". <br/>
    In the dialog, only select the method `GetAmount` and press OK. <br/>
    Move the logic from the superclass to the `TragedyCalculator.GetAmount` and just to be extra paranoid throw a `NotImplementedException` in the "Tragedy" leg of `PerformanceCalculator.GetAmount`<br/>
    Compile-test-commit.

4. Repeat for each conditional.<br/>
    Apply the same process on the `GetAmount` method for the `ComedyCalculator`.<br/>
    Compile-test-commit.<br/>

And with that, we reach the last step of the refactoring:

5. Change the method in the superclass.
    As there is no default calculation for the amount, we want to signal our future self (or colleagues) that this is the responsibility of a subclass
by throwing a `NotImplementedException`.
```c#
        public virtual int GetAmount() => throw new NotImplementedException("subclass responsibility");
```
    Compile-test-commit.

However as we are not yet ready with moving all conditionals, repeat step 4 and 5 for `GetVolumeCredits` for `ComedyCalculator`.<br/>
Do note that there is a default implementation on the superclass.<br/>
Compile-test-commit.

Your `TheatricalPlays` project should look something like the one in folder `src\05 Calculations per type`

# Done!
As you've just experienced yourself, with an systematic approach, we are able to safely improve the design and readability of existing code without breaking external behavior.

If we take a second look at `EnrichedPerformance` then we will notice that all the data in this intermediate data-structure is also encapsulated in `PerformanceCalculator` and its subclasses.

As a last exercise, see if you can change the `GetAmount` and `GetVolumeCredits` method into properties (hint: use the quick actions) and afterwards if you can safely remove the `EnrichedPerformance` class.

For an idea how the project could like after the removal and some re-structuring and inlining, see `src\06 Optional`