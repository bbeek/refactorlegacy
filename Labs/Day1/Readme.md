# Refactoring "TheatricalPlays"
===============================
Background: 

This project contains a bill generator for a theatrical company.
This company charges their customers based on the size of the audience and the type of play.
Currently they are using a .NET 5 console application to generate a plain text bill.

Beside providing a bill, it also outputs the customers "volume credits", which is used to calculate a discount for repeat customers.
Every 10 credits earns a customer 1 percentage point up to a maximum discount of 30% of the total bill.

The plays this company can perform are stored in a simple JSON file.
In another JSON file are the performances stored that were performed for a customer containing the playid and the audience.

## Target Environment
* .NET Core 5.0
* This lab expects the default keybindings. If you're using a different keymap, please look up the keyboard shortcuts used in this lab.

### Build
* Visual Studio 2019 v16.8+ 

# Goal
======
The company wants to perform more types of plays. 
They hope to perform: historical, pastoral, pastoral-comical, historical-pastoral, tragical-comical-historical-pastoral and poem unlimited
Although the pricing structure and the volume credit calculations are not fully worked out, it appears that this will be under subject of change in the near future.

Furthermore, the company wants to send out HTML formatted statements to some customers.

In order to do so, you would either have to copy-paste the current `BillGenerator.Statement` implementation into a HTML statement generator with all code duplicated.

Or, first refactor the current implementation to a improved design more suitable for the upcoming features/requests.

In this lab we are going to perform the steps needed for the latter (of course :))

# First steps
=============
## Extract function
As a first step, let's begin by extracting functionality from the current long `Statement` function.
The `switch` statement related to calculating the charge of a performance is a good start as it is performs 1 thing that we can return in a method.

So we are going to perform a **Extract Method** on this statement.
Select line 22 till 40 in `BillGenerator.cs` and apply the **Extract method** refactoring from Visual Studio (either via Edit > Refactor > Extract Method or using the Ctrl+. "quick actions" > Extract )
And name the newly extracted function `AmountFor`. (We can always rename it later to a more suitable name).
We finish the first refactoring by running our unittests to verify that we did not break anything and committing the first change

Next, apply the **Rename variable** refactoring from Visual Studio on the `thisAmount` variable in the `AmountFor` method and rename it to `result`
Again compile-test-commit.

Apply the same **Rename variable** refactoring on the `perf` parameter of `AmountFor`. Rename it to `performance`, compile test and commit.

## Removing the `play` variable
The next refactoring we want to apply is regarding the `play` parameter. This parameter is just a computation based on the performance playID
and as we already have a Performance object as parameter, there should not be a need to pass it in as we could also calculate it ourselves.
Meaning that we want to remove the `play` parameter.

However here the design of the `Statement` method holds us back, because the dictionary containing all plays is a local parameter.
Meaning that we need to promote the `plays` parameter into a instance variable (in C# called Fields) of the class `BillGenerator`
Let's start with adding `private readonly IReadOnlyDictionary<string, Play> plays;` to the top of the class.

Now we *could* assign the `plays` parameter directly to the instance variable by using `this.plays = plays;` within the Statement method, 
however this would set us on a slippery slope as it would not be easy to separate between the local parameter and the instance variable.
Instead we want to signal to the users of `BillGenerator` that it always requires a `IReadOnlyDictionary<string, Play> plays` using the constructor.

The new constructor can automatically be generated by Visual Studio. 
Place the text cursor/caret somewhere within the `BillGenerator` on line 8 and bring up the "quick actions" menu using Ctrl+.
Select the "Generate constructor..." option. Press "OK" on the dialog and a constructor should be generated.
Now we can use the **_lean on compiler_** action to identify all the places that need to be changed due to the added constructor parameter.
Resolve each compiler error.

Finally we are going to switch into using the instance variable by removing the `plays` parameter using the **Change function declaration** refactoring.
Place the cursor somewhere on the line `public string Statement(Invoice invoice, IReadOnlyDictionary<string, Play> plays)` and bring up the "quick actions" menu.
Select the "Change signature..." option. In the dialog that opens, select the `plays` parameter, press the Remove button and finally press "OK" to apply the changes.
With this refactoring, the instance variable should now be used.
Test the changes to ensure that the external behavior was not modified and commit if all tests are green.

Next encapsulate the lookup of a play based on it's performance in a separate function.
Select this whole line `var play = plays[perf.PlayId];` (around line 28 within `Statement` function), 
apply the **Extract Method** refactoring and name the newly created method `PlaysFor`.
Compile-test-commit.

Apply the **Inline variable** refactoring on the `play` variable.
Place the cursor on the `play`, bring up the "quick actions" context menu and select the option "Inline temporary variable".
As always after a refactor action, compile-test-commit.

With this new `PlaysFor` function, we can begin removing the `play` parameter from the `AmountFor` function.
First, use the new function in `amountFor` by replacing the 2 usages of the `play` variable with a call to `PlaysFor(performance)`.
And as `AmountFor` now uses non-static methods, remove the static keyword.
Compile-test-commit

Then delete the now unused `play` parameter using the **Change function declaration** refactoring.
And compile-test-commit again.

As a final refactoring during this step, apply the **Inline variable** refactoring on the `thisAmount` variable

Your `BillGenerator` class should look something like the one in folder `src\01 First Steps`

# Extracting Volume Credits
Next we want to extract the `volumeCredits` calculation from the foreach loop.
Unfortunately due to `volumeCredits` accumulator, we cannot rely on the automated "Extract method" functionality.
Instead we are going to perform the **Extract Method** refactoring manually. 
First create a new method named `VolumeCreditsFor`:
```c#
private int VolumeCreditsFor(Performance perf)
{

}
```
Then copy the volume credit calculation block into `VolumeCreditsFor`:
```c#
private int VolumeCreditsFor(Performance perf)
{
    // add volume credits
    volumeCredits += Math.Max(perf.Audience - 30, 0);
    // add extra credit for every ten comedy attendees
    if (PlayType.Comedy == PlaysFor(perf).Type) volumeCredits += (int)Math.Floor((decimal)perf.Audience / 5);
}
```
Add the missing variable to resolve the compiler errors and return it:
```c#
private int VolumeCreditsFor(Performance perf)
{
    var volumeCredits = 0;
    // add volume credits
    volumeCredits += Math.Max(perf.Audience - 30, 0);
    // add extra credit for every ten comedy attendees
    if (PlayType.Comedy == PlaysFor(perf).Type) volumeCredits += (int)Math.Floor((decimal)perf.Audience / 5);

    return volumeCredits;
}
```

Replace to copied code with a call to `VolumeCreditsFor`:
```c#
            foreach (var perf in invoice.Performances)
            {
                volumeCredits += VolumeCreditsFor(perf);
```

Compile-test-commit the manual Extract Method refactoring.
Lastly, remove the unnecessary (and even misleading) comments and **Rename variable** in the new function, 
renaming `volumeCredits` to result and `perf` to `performance` with a compile-test-commit action for each rename.

Next we are going to remove the `volumeCredits` from `Statement`.
As it is nested in the foreach loop, we are going to apply the **Split Loop** refactoring (see slides)
```c#
            foreach (var perf in invoice.Performances)
            {
                // print line for this order
                result.Append($"  {this.PlaysFor(perf).Name}: {(AmountFor(perf) / 100).ToString("C", format)}");
                result.AppendLine($" ({perf.Audience} seats)");
                totalAmount += AmountFor(perf);
            }

            foreach (var perf in invoice.Performances)
            {
                volumeCredits += VolumeCreditsFor(perf);
            }
```
Compile-test-commit

Then using **Slide Statements** (see hidden slide 20) move the declaration of the `volumeCredits` variable before the loop:
```c#
            var volumeCredits = 0;
            foreach (var perf in invoice.Performances)
            {
                volumeCredits += VolumeCreditsFor(perf);
            }
```
Compile-test-commit

Gathering this all together means that we can now use the automated **Extract Method** refactoring to create a new method `GetTotalVolumeCredits`.
After compiling, testing and committing; apply **Inline variable** on `volumeCredits`

Your `BillGenerator` class should look something like the one in folder `src\02 Extract Volume Credits`

# More extractions
In order to remove the variable `totalAmount` we can use the same steps as before.
First **Split loop* on the first foreach loop.
After this refactoring it should look like below:
```c#
            foreach (var perf in invoice.Performances)
            {
                // print line for this order
                result.Append($"  {this.PlaysFor(perf).Name}: {(AmountFor(perf) / 100).ToString("C", format)}");
                result.AppendLine($" ({perf.Audience} seats)");
            }

            foreach (var perf in invoice.Performances)
            {
                totalAmount += AmountFor(perf);
            }
```
Compile-test-commit.

Then using **Slide Statements** on `decimal totalAmount = 0;` closer to the loop. 
Compile-test-commit
Select all the lines related to calculating `totalAmount`, including the discount, and apply **Extract Method** refactoring to create a new method `GetTotalAmount`.
Compile-test-commit
**Inline variable** `totalAmount` (compile-test-commit) in `Statement`  function.
In `GetTotalAmount` method **Rename variable** `totalAmount` to `result`

Lastly let's extract the currency formatting.
As both the `AmountFor(perf)` and `GetTotalAmount(invoice)` use the same kind of code, let's **Extract method** on this functionality.
Here we need to again perform a manual refactoring as the automated tooling does not suffice.
Given that this method will format an amount into USD, we could name it as `FormatAsUSD` but `Usd` is just as suggestive so we go with latter.
```c#
        private string Usd(decimal amount)
        {

        }
```

Next, move the code related to the amount formatting in the new function:
```c#
        private string Usd(decimal amount)
        {
            IFormatProvider format = new CultureInfo("en-US");
            return (amount / 100).ToString("C", format);
        }
```
Note that we included the duplicate division by 100 into the `Usd` method.
Now, replace the number formatting with the `Usd` method. 
Testing after each replacement.
Remove the used `format` variable from `Statement`

As a final refactoring in this part, **Inline variable** on `format` in `Usd`

Your `BillGenerator` class should look something like the one in folder `src\03 More extractions`

# Split phase and adding render HTML
So far, we worked on bringing structure onto the original function so that we can easily understand the various parts.
In order to add the HTML support, we could stop now, just copy the seven or so lines remaining in `Statement`, create an HTML variant and call it a day.
This does mean however that the logic for what is required to generate a bill is still duplicated.

Therefor we are now going to apply the **Split Phase** refactoring to untangle the logic for calculating the statement data from the logic for rendering text (or later HTML)
As a reminder, with the **Split Phase** refactoring, we begin by extracting the second phase. 
Then create an intermediate data structure, for encapsulation the data calculated in the first phase, followed by gradually copying over all properties onto this structure.
And lastly, extracting the first phase.

Given that the second phase of the `Statement` function is that of rendering the plaintext bill, we begin by applying the **Extract method** on all the lines in `Statement`.
And we're going to give this method a name descriptive of the second phase, so let's name it: `RenderPlainText`.
Now `Statement` function should look like this:
```c#
        public string Statement(Invoice invoice)
        {
            return RenderPlainText(invoice);
        }
```

Compile-test-commit.

## Creating intermediate data structure `StatementData`
Then create a intermediate data structure. Right-click on the `TheatricalPlays` project within the Solution Explorer and add a new class named `StatementData`.
Next, using the **Change function declaration** (use the change signature functionality in Visual Studio) add a new parameter to the `RenderPlainText` method of type `StatementData` with name `data`.
Create a new variable `statementData` in `Statement` and pass it into the `RenderPlainText` method.
Now the solution should be in a compilable state.
So, we start the process of moving data required for the second phase into the intermediate data structure.

We begin by moving the Customer data into the `StatementData` class. First add `public string Customer { get; init; }` to the `StatementData` class.
> **Note** that we enforce encapsulation to the data by only allowing the name to be set with the constructor by specifying the new **_.Net 5 `init` accessibility modifier_**.
> This defaults into a `private set` without a need for a parameterized constructor and thus ensuring immutability
Change the usage from `invoice.Customer` within `RenderPlainText` into `data.Customer` and add `invoice.Customer` as parameter of the `new StatementData` call.
Compile-test-commit.

The `Statement` method should now look something like this:
```c#
        public string Statement(Invoice invoice)
        {
            var statementData = new StatementData{ Customer = invoice.Customer };
            
            return RenderPlainText(invoice, statementData);
        }
```
And the first few lines of `RenderPlainText` should now look like this:
```c#
        private string RenderPlainText(Invoice invoice, StatementData data)
        {
            var result = new StringBuilder().AppendLine($"Statement for {data.Customer}");

            foreach (var perf in invoice.Performances)
```

We repeat the same process for the `Performances` property. 
Because we want to be sure that this list does not change while we query it, we are going to make the new property of type `ImmutableList`.
Like so: `public ImmutableList<Performance> Performances { get; init;}`. 
Ensure that the updated constructor is called with the correct parameters within `Statement` and that the foreach loop in `RenderPlainText` now uses `data.Performances`.
Compile-test-commit.

Given that both `GetTotalVolumeCredits` and `GetTotalAmount` also use the `invoice.Performances` collection, we want to change both of them into using the `StatementData` intermediate structure.
We start by adding a `StatementData` parameter named `data` to `GetTotalAmount` using the **Change function declaration** refactoring.
If we choose the option `Infer from context` in the "Values to inject in call sites", Visual Studio will fill in the correct parameter within `RenderPlainText`.
Change the `invoice.Performance` invocation into `data.Performances`.
Compile-test-commit.

Then repeat the same steps for `GetTotalVolumeCredits`. Add a StatementData parameter named `data` to `GetTotalVolumeCredits` using the **Change function declaration** refactoring.
Again choose the option `Infer from context`.
Changing into the usage of `data.Performances`.
Compile-test-commit.

With that refactoring, the `invoice` parameter on `GetTotalVolumeCredits` in no longer required. 
Remove this parameter using the **Change function declaration** refactoring.
Compile-test-commit.

And as a result to the clean up within `GetTotalVolumeCredits`, the `invoice` parameter on `GetTotalAmount` is now no longer used.
Remove this parameter using the **Change function declaration** refactoring.
Compile-test-commit.

Finally we can also remove the `invoice` parameter from `RenderPlainText`. Again remove using **Change function declaration** refactoring and finish with compile-test-commit.

## Creating intermediate data structure `EnrichedPerformance`
The next thing we want to move into the intermediate data structure is the retrieval of the play for each performance.
This points us towards yet another intermediate data structure, namely one that encapsulates an enriched performance object.

Add a new class named `EnrichedPerformance` that inherits from `Performance`. Given that we are using the new **_.Net 5 record functionality_**, we need to change `class` into **`record`**.
and create a internal constructor for `EnrichedPerformance` that takes a `Performance` as parameter.
Hint: use the quick actions context menu on EnrichedPerformance to create this constructor and manually change the accessibility from `protected` to `internal`
```c#
namespace TheatricalPlays
{
    record EnrichedPerformance : Performance
    {
        internal EnrichedPerformance(Performance original) : base(original)
        {
        }
    }
}
```

Then change the type used in `StatementData.Performances` to `ImmutableList<EnrichedPerformance>` (updating both the property and the constructor).

We now need to convert the list of `Performance`s into `EnrichedPerformance`. Here we are going to use the `ConvertAll` method from the `ImmutableList` class to ensure that a new immutable list is returned.
This does however require a method that takes in a `Performance` and returns a `EnrichedPerformance` object.
So, add within `BillGenerator` a new private method named `EnrichPerformance` with the appropriate input and output types.

Now your `Statement` method should look like this:
```c#
        public string Statement(Invoice invoice)
        {
            var statementData = new StatementData{ Customer = invoice.Customer, Performances = invoice.Performances.ConvertAll(EnrichPerformance) };
            
            return RenderPlainText(invoice, statementData);
        }
```

Having prepared the groundwork for the second intermediate data structure, move the `Play` property into `EnrichedPerformance` 
and ensure immutability by only specifying a `get`. (This forces a `private set` and the need to set this property via a parameterized constructor).
Add the `Play` parameter to the constructor by placing the caret on 'Play' property, bring up the quick actions context menu and select the "Add parameters to constructor" option.

Resolve the compiler error by adding a call to the `PlaysFor` method as argument for the second parameter in the `new` call in `EnrichPerformance`:
```c#
        private EnrichedPerformance EnrichPerformance(Performance performance)
        {
            return new EnrichedPerformance(performance, PlaysFor(performance));
        }
```
Replacing the call to `PlaysFor(perf)` within `RenderPlainText` with `perf.Play`.
Compile-test-commit

The next thing to move is the `Amount` property. 
We start by adding `Amount` as a get only property to `EnrichedPerformance`. 
Add the new property to `EnrichedPerformance` constructor using Visual Studio quick actions context menu.
Initialize the new argument using a call to `AmountFor(performance)` within `EnrichPerformance`.
Then, in **_all_** methods that use the intermediate data structure `StatementData`, we replace the usage of `AmountFor(perf)` with `perf.Amount`.
Compile-test-commit. (For those wanting to also move the `AmountFor` method, we are going to apply that refactoring in a later stage).

The last property to be moved into the `EnrichedPerformance` data structure is `VolumeCredits`
Repeat the steps above only now for `VolumeCreditsFor` and compile-test-commit.

## Back to intermediate data structure `StatementData`
We move on the replacing the calculation of the two totals.

First let's create a new property `public decimal TotalAmount { get; set; }` within `StatementData`.
As this property is settable from the outside, assign the TotalAmount property with `statementData.TotalAmount = GetTotalAmount(statementData);`.
Replace `GetTotalAmount(data)` in `RenderPlainText` with `data.TotalAmount`.
Compile-test-commit.
Repeat this process for the property `TotalVolumeCredits`. When replacing the usage of `GetTotalVolumeCredits(data)` with `data.TotalVolumeCredits`, also update the `GetTotalAmount` method.
Verify that all unittests are green, if not, then we broke the TotalAmount calculation as the volume credits calculation was not yet performed.
This shows us why it remains important to test after each step.
Resolve the introduced bug by, for now, switching the order of the `TotalAmount` and `TotalVolumeCredits`.

All tests should now be green again, and `Statement` should look like this:
```c#
        public string Statement(Invoice invoice)
        {
            var statementData = new StatementData{ Customer = invoice.Customer, Performances = invoice.Performances.ConvertAll(EnrichPerformance) };
            statementData.TotalVolumeCredits = GetTotalVolumeCredits(statementData);
            statementData.TotalAmount = GetTotalAmount(statementData);
            
            return RenderPlainText(statementData);
        }
```

As the current state is very fragile, we are going to move the total calculation into the `StatementData` class.
Copy the `GetTotalAmount` function to `StatementData`. Adjust it to the new context by removing the `data` parameter and using `this` instead of `data`.
Change the `TotalAmount` property into a pass through call to `GetTotalAmount`: `public decimal TotalAmount => GetTotalAmount();`
With that change, we can remove the assignment of `TotalAmount` in `Statement`.
Compile-test-commit. Remove the dead code of `GetTotalAmount` in `BillGenerator`. Always a satisfying feeling!

Repeat the above steps for `GetTotalVolumeCredits`.
Compile-test-commit

Before we wrap it up, apply the **Replace loop with pipeline** refactoring on each of the total calculation functions.
Compile-test-commit.

```c#
        private decimal GetTotalAmount()
        {
            decimal totalAmount = this.Performances.Sum(perf => perf.Amount);

            var discountPercentage = Math.Min(30, (this.TotalVolumeCredits / 10));
            totalAmount -= totalAmount * (discountPercentage / 100m);
            return totalAmount;
        }

        private int GetTotalVolumeCredits()
        {
            return this.Performances.Sum(perf => perf.VolumeCredits);
        }
```

## Adding HTML support
Remember that we started all these refactorings as part of the **Split phase** refactoring. 
Now that all data calculations have be encapsulated in `StatementData`, we can apply the last step of this refactoring.
This is the extraction of the first step.
Apply the **Extract Method** refactoring on `var statementData = new StatementData{ Customer = invoice.Customer, Performances = invoice.Performances.ConvertAll(EnrichPerformance) };`
and we are going to call the new method `CreateStatementData`.
Compile-test-commit.

Apply the **Inline variable** on the `statementData` variable.
```c#
        public string Statement(Invoice invoice)
        {
            return RenderPlainText(CreateStatementData(invoice));
        }
```

And with that we are ready to add the HTML version:
```c#

        public string HtmlStatement(Invoice invoice)
        {
            return RenderHtml(CreateStatementData(invoice));
        }

        private string RenderHtml(StatementData data)
        {
            var result = new StringBuilder().AppendLine($"<h1>Statement for {data.Customer}</h1>");
            result.AppendLine("<table>");
            result.Append("<tr><th>play</th><th>seats</th><th>cost</th></tr>");
            foreach (var perf in data.Performances)
            {
                result.Append($"  <tr><td>{perf.Play.Name}</td><td>{perf.Audience}</td>");
                result.AppendLine($"<td>{Usd(perf.Amount)}</td></tr>");
            }
            result.AppendLine("</table>");
            result.AppendLine($"<p>Amount owed is <em>{Usd(data.TotalAmount)}</em></p>");
            result.AppendLine($"<p>You earned <em>{data.TotalVolumeCredits}</em> credits</p>");
            return result.ToString();
        }
```

Easy.

Your `BillGenerator` class should look something like the one in folder `src\04 Split Phase`

# Calculations by type
